---
title: "6. praktikum"
knit: (function(input_file, encoding) {
    out_dir <- 'docs';
    rmarkdown::render(input_file,
      encoding=encoding,
      output_file=file.path(dirname(input_file), out_dir, '6-tidyverse.html'))})
date: 09.03.2022
output: 
  html_document:
    theme: flatly
    highlight: tango
    self_contained: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pakett `tidyverse` {.tabset .tabset-pills}

## Tidyverse

Pakett `tidyverse` on andmeanalüüsi n-ö komplekspakett, mis koondab enda alla terve hulga teisi pakette ja nende funktsioone (sh `ggplot2`). Ehkki enamikku sellest, mida need funktsioonid teevad, saab ära teha ka teiste pakettide ja funktsioonidega, ühendab *tidyverse*'i pakette sarnane kasutusloogika ja sarnaste andmestruktuuride kasutus.     

<center>
![](imgs/tidyverse.jpg){width=50%}
</center>

*Tidyverse*'i pakette saab mõistagi installida ka ükshaaval (nt `install.packages("tidyr")`). Kiire ülevaate üksikute pakettide põhifunktsioonidest saad nt erinevatest spikritest:  

- [`ggplot2` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)  
- [`dplyr` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)  
- [`tidyr` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/tidyr.pdf)  
- [`purr` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf)  
- [`readr` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-import.pdf)  
- [`stringr` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/strings.pdf)  
- [`forcats` spikker](https://raw.githubusercontent.com/rstudio/cheatsheets/main/factors.pdf)  

*Tidyverse*'i installimiseks kasuta käsku `install.packages("tidyverse")` ning laadimiseks `library(tidyverse)`.  

```{r, message=F}
# install.packages("tidyverse")
library(tidyverse)
```
Ära muretse, kui paketi laadimise käigus konsooli midagi trükitakse.  

Laadime ka jälle küsimustiku andmestiku, mida põhiliselt kasutame.  

```{r}
load("data/kysimustik_2022.RData")
```


## Torud  

*Tidyverse*'i pakette ühendab sarnane kindlas järjekorras asjade tegemise loogika. Üks paketi oluline omadus on võimalus kasutada nn **torusid** ehk *pipe*'e (sümbol `%>%`). Torud lubavad tõsta R-i n-ö pesastatud funktsioonidest funktsioone välja nende käivitamise järjekorra alusel, suunates iga eelmise käsu väljundi järgmisse käsku.  
Kui R-i baaspaketis on kõige viimane käsk graafiliselt kõige esimene, siis torud lubavad teha neid asju loogilisemas järjekorras. Võrdle näiteks:  

```{r, eval = F}
# Leia lemmiklooma suhtelised sagedused

# baaspakett
prop.table(table(kysimustik$lemmikloom))

# tidyverse
kysimustik$lemmikloom %>% 
  table() %>% 
  prop.table()
```

```{r, eval = F}
# Leia õppekava nimetustes esinevate unikaalsete sõnavormide arv

# baaspakett
length(unique(unlist(strsplit(as.character(kysimustik$oppekava), split = " "))))

# tidyverse
kysimustik$oppekava %>%
    as.character() %>%
    strsplit(" ") %>%
    unlist() %>%
    unique() %>%
    length()
```

Nagu baaspaketis ei ole vahet, kas komadega eraldatud argumendid on eraldi ridadel või ühel real, ei ole seda vahet ka *tidyverse*'is. Samuti ei ole vahet, kas torudega eraldatud funktsioonid jätta samale reale või viia need eraldi ridadele. 
*Tidyverse*'i toru kiiremaks kasutamiseks võid kasutada ka klahvikombinatsiooni `Ctrl+Shift+M` (Macis `Shift+Cmd+M`).  

Tõele au andes on uuemates R-i versioonides ka baaspaketis juba oma *toru* `|>`, mis töötab enam-vähem samamoodi nagu *tidyverse*'i toru.    

```{r, eval = F}
kysimustik$oppekava |> 
    as.character() |>
    strsplit(" ") |>
    unlist() |>
    unique() |>
    length()
```

Kumba või kas üldse kasutada, on maitse küsimus, aga kui juba muid *tidyverse*'i funktsioone on vaja kasutada, tundub loogilisem kasutada ka vastavat toru `%>%`.  


## Andmete filtreerimine ja valimine

Baaspaketis oleme harjunud andmestikest mingi konkreetse alamosa väljavõtmiseks kasutama kantsulgusid ning nende sees võrratusi.
Kordamiseks põhilised võrratustes kasutatud tehted:  



|Sümbol|Näide   |Selgitus                |Sobiv tunnusetüüp                    |
|:-----|:-------|:-----------------------|:------------------------------------|
|`==`  |`a == b`|a võrdub b-ga           |arvulised, kategoriaalsed, loogilised|
|`!=`  |`a != b`|a ei võrdu b-ga         |arvulised, kategoriaalsed, loogilised|
|`>`   |`a > b` |a on suurem kui b       |arvulised, loogilised                |
|`<`   |`a < b` |a on väiksem kui b      |arvulised, loogilised                |
|`>=`  |`a >= b`|a on suurem/võrdne b-ga |arvulised, loogilised                |
|`<=`  |`a <= b`|a on väiksem/võrdne b-ga|arvulised, loogilised                |


Lisaks on kasulik funktsioon `is.na()`, mis otsib välja ainult read või elemendid, mille väärtus on NA (nt `is.na(a)`) või ei ole NA (`!is.na(a)`).  

<br>

Liittehted:  

|Sümbol |Näide               |Selgitus                                |
|:------|:-------------------|:---------------------------------------|
|`&`    |`a == b & a != c`   |a on võrdne b-ga JA a ei ole võrdne c-ga|
|`|`    |`a == b | a == c`   |a on võrdne b-ga VÕI a on võrdne c-ga   |
|`%in%` |`a %in% c(b, c, d)` |a väärtus on b VÕI c VÕI d              |
|`!%in%`|`!a %in% c(b, c, d)`|a väärtus ei ole b EGA c EGA d          |



Keerulisemate võrratuste puhul võib pilt minna päris kirjuks.    

```{r, eval = F}
# ainult s-u keeleteaduse üliõpilaste andmed
kysimustik[kysimustik$oppekava == "eesti ja soome-ugri keeleteadus",]

# kõikide üliõpilaste, v.a s-u keeleteaduse üliõpilaste andmed, kes on õppinud kauem kui 5 aastat
kysimustik[kysimustik$oppekava != "eesti ja soome-ugri keeleteadus" & kysimustik$kaua_opid > 5,]

# nende s-u keeleteaduse ja/või ajaloo üliõpilaste sünniaastad, kes on õppinud kauem kui 5 aastat
kysimustik[(kysimustik$oppekava == "eesti ja soome-ugri keeleteadus" | kysimustik$oppekava == "ajalugu") & kysimustik$kaua_opid > 5, "synniaasta"]
kysimustik[kysimustik$oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kysimustik$kaua_opid > 5, "synniaasta"]

# kõikide kauem kui 5 aastat õppinute, v.a s-u keeleteaduse ja/või ajaloo üliõpilaste sünniaastad ja lemmikloomad
kysimustik[!kysimustik$oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kysimustik$kaua_opid > 5, c("synniaasta", "lemmikloom")]

```

*Tidyverse* lubab meil kasutada funktsiooni **`filter()`** ridade filteerimiseks ning funktsiooni **`select()`** tulpade valimiseks. Sealjuures säilitab `select()` andmetabeli struktuuri. 

```{r, eval = F}
# ainult s-u keeleteaduse üliõpilaste andmed
# kysimustik[kysimustik$oppekava == "eesti ja soome-ugri keeleteadus",]
kysimustik %>% 
  filter(oppekava == "eesti ja soome-ugri keeleteadus")

# ainult õppekava tulp
kysimustik %>% 
  select(oppekava)
```

Kui tahame pärast toru võtta mingi tulba välja vektorina (või faktorina), saame viidata tabelile punktiga: `... %>% .$tulp`. Punkt on nn *placeholder*, mis laseb torudega toimetades viidata vahetult eelmise käsu väljundile.  

```{r, eval = F}
kysimustik %>%
  filter(kaua_opid > 5) %>%
  .$oppekava
```

Tulba küsimiseks vektorina võib kasutada ka *tidyverse*'i funktsiooni **`pull()`**. Kui tahta funktsiooni kasutada faktoril, tuleb faktor esmalt tavaliseks tekstivektoriks teisendada.   

```{r}
kysimustik %>%
  filter(kaua_opid > 5) %>%
  pull(oppekava)
```


Mitme tingimusega filtreerimiseks võime kasutada ära torusid ja rakendada igat filtrit eraldi käsuna või liita tingimused samamoodi, nagu seda saab teha baaspaketis.    

```{r, eval = F}
# kõikide üliõpilaste, v.a s-u keeleteaduse üliõpilaste andmed, kes on õppinud kauem kui 5 aastat
# kysimustik[kysimustik$oppekava != "eesti ja soome-ugri keeleteadus" & kysimustik$kaua_opid > 5,]
kysimustik %>%
  filter(oppekava != "eesti ja soome-ugri keeleteadus") %>%
  filter(kaua_opid > 5)
# või
kysimustik %>% 
  filter(oppekava != "eesti ja soome-ugri keeleteadus" & kaua_opid > 5)

# nende s-u keeleteaduse või ajaloo üliõpilaste sünniaastad, kes on õppinud kauem kui 5 aastat
# kysimustik[kysimustik$oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kysimustik$kaua_opid > 5, "synniaasta"]
kysimustik %>%
    filter(oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kaua_opid > 5) %>%
    select(synniaasta)
# võrdle
kysimustik %>%
    filter(oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kaua_opid > 5) %>%
    .$synniaasta

# kõikide kauem kui 5 aastat õppinute, v.a s-u keeleteaduse või ajaloo üliõpilaste sünniaastad ja lemmikloomad
#kysimustik[!kysimustik$oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kysimustik$kaua_opid > 5, c("synniaasta", "lemmikloom")]
kysimustik %>%
    filter(oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu") & kaua_opid > 5) %>%
    select(synniaasta, lemmikloom)
```

Saame filtreerimisel kasutada ka teiste pakettide (sh vaikimisi laaditud baaspaketi ja `stats` paketi) funktsioone.  

```{r, eval = F}
# osalejad, kelle sünniaasta on suurem kui sünniaasta mediaanväärtus
kysimustik %>%
  filter(synniaasta > median(synniaasta))
```


## Andmete järjestamine

Andmete järjestamiseks mingi tulba väärtuste alusel võib kasutada funktsiooni **`arrange()`**.  

```{r, eval = F}
kysimustik %>% 
  arrange(synniaasta) # kasvavas järjekorras

kysimustik %>% 
  arrange(desc(synniaasta)) # kahanevas järjekorras
```

Võime järjestada andmeid ka mitme tunnuse järgi korraga.  

```{r, eval = F}
kysimustik %>%
  filter(oppekava %in% c("eesti ja soome-ugri keeleteadus", "ajalugu")) %>%
  select(synniaasta, lemmikloom) %>%
  arrange(desc(synniaasta), lemmikloom)
```


## Tulpade lisamine

Tulpade lisamiseks tabelisse saab kasutada funktsiooni **`mutate()`**.

Lisame näiteks küsimustiku tabelisse tulba, kuhu arvutame iga osaleja vanuse kursusel osalemise ajal. Kuna täpset sünniaega me ei tea ja küsimustikule vastatakse tavaliselt veebruari alguses, siis peame leppima sellega, et võime tegelikke vanuseid 1 aasta võrra üle hinnata.  
Kuna `aasta` on praeguses tabelis faktor, peame sellega arvutamiseks teisendama selle esmalt tekstiks ning seejärel arvuliseks tunnuseks.

```{r, eval = F}
kysimustik %>%
  mutate(vanus = as.numeric(as.character(aasta))-synniaasta)
```



## Jooniste tegemine

*Tidyverse*'i üks suuri plusse on see, et me ei pea vaheväljundeid eraldi objektidesse salvestama, kui tahame neid hiljem millekski muuks kasutada. Nii võime ka kogu andmete puhastamise ja korrastamise protsessi väljundi suunata otse graafikule.  

```{r, eval = F}
# Kuva karpdiagrammil vanuse jaotumist eri aastatel ning lemmikjoogi põhjal
kysimustik %>%
  mutate(vanus = as.numeric(as.character(aasta))-synniaasta) %>%
  ggplot() + # NB! +, mitte %>%
  geom_boxplot(aes(x = aasta, y = vanus, fill = lemmikjook))
```

## Harjutused

**Harjutus 1**  

Leia torusid kasutades, millisel aastal on olnud kursusel kõige rohkem kohvijoojaid. Ärme esialgu sellepärast muretseme, kui palju osalejaid mingil aastal üldse kursuselt läbi käis.  

1. Filtreeri andmetest ainult kohvijoojate read.  
2. Võta välja ainult aasta tulp.  
3. Tee risttabel käsuga `table()`.  
4. Leia moodi indeks käsuga `which.max()`.  
5. Leia mood ise käsuga `names()`.  


```{r, class.source = 'fold-hide', eval = F}
kysimustik %>% 
    filter(lemmikjook == "Kohv") %>%
    select(aasta) %>%
    table() %>%
    which.max() %>%
    names()
```

**Harjutus 2**

Loe sisse kandidaatide andmestik `kandidaadid.RData`. Lisa tabelisse uude tulpa kandidaatide vanused valimispäeval (3. märts 2019). Näita joonisel, milline oli vanuste jaotus erakondades ning kas vanus mõjutas kuidagi ka (logaritmitud) häältesaaki.  

1. Tee kandidaatide andmestikku uus tulp nimega `vanus`. Vanuse leidmiseks kasuta paketti `lubridate` ja selle funktsiooni `time_length()`: `lubridate::time_length(as.Date("2019-03-03")-kandidaadid$sunniaeg, "years") %>% round(., 0)`.   
2. Tee ggplotiga all näidatud karpdiagramm. Joonise saad "külili keerata", kui lisad kihi `coord_flip()`. Punase joone saad kihiga `geom_hline()`.    

```{r, results = 'hide', class.source = 'fold-hide'}
# install.packages("lubridate")
load("data/kandidaadid.RData")
kandidaadid %>%
  mutate(vanus = lubridate::time_length(as.Date("2019-03-03")-kandidaadid$sunniaeg, "years") %>% round(., 0)) %>%
  ggplot() +
  geom_boxplot(aes(x = nimekiri_voi_uksikkandidaat, y = vanus)) +
  geom_hline(aes(yintercept = mean(vanus)), color = "red", linetype = "dashed", size = 1) +
  coord_flip() +
  labs(x = "")
```

3. Võta sama vanusega andmestik ja tee joonisel näidatud hajuvusdiagramm nii, et häältesaaki ei näidataks mitte absoluutarvudes, vaid logaritmituna (`log(tunnus)`).  

```{r, results = 'hide', class.source = 'fold-hide', message=F}
kandidaadid %>%
  mutate(vanus = lubridate::time_length(as.Date("2019-03-03")-kandidaadid$sunniaeg, "years") %>% round(., 0)) %>%
  ggplot(aes(x = vanus, y = log(haali_kokku))) +
  geom_point(alpha = 0.3) +
  geom_smooth()
```




**Harjutus 3**  

Oletame, et keegi küsib meilt Keskerakonna nimekirjas kandideerinute meiliaadresse. Meiliaadressid on tulbas `kontaktandmed`, aga seal on ka telefoninumbrid ja tavalised aadressid. Peaksime niisiis kasutama pisut regulaaravaldisi, et need eraldi kätte saada ja uude tulpa lisada. Ära muretse, kui sa regulaaravaldisi veel ei tunne.      

1. Jäta alles ainult read, kus tunnuse `nimekiri_voi_uksikkandidaat` on "Eesti Keskerakond".  
2. Tee uus tulp nimega `meil`, kuhu saad väärtused käsuga `ifelse(grepl("@", kontaktandmed), gsub("^.*?([^@ ,]+@[^@ ,]+).*$", "\\1", kontaktandmed) %>% str_trim(), "")`.  
3. Vali ainult nimede ja meiliaadresside tulbad.  
4. Jäta alles ainult read, kus tunnuse `meil` väärtus ei ole tühi (`""`).  

```{r, eval = F, class.source = 'fold-hide'}
kandidaadid$nimekiri_voi_uksikkandidaat %>% unique() # kuidas Keskerakonnale on tabelis viidatud?
kandidaadid$kontaktandmed %>% unique() # millise struktuuriga on kontaktandmeid esitatud?

kandidaadid %>%
  filter(nimekiri_voi_uksikkandidaat == "Eesti Keskerakond") %>%
  mutate(meil = ifelse(grepl("@", kontaktandmed), # tee uus tulp "meil", kuhu juhul, kui kontaktandmete tulbas on @-märk,
                       gsub("^.*?([^@ ,]+@[^@ ,]+).*$", "\\1", kontaktandmed) %>% str_trim(), # läheb ainult meiliaadressi osa
                       "")) %>% # kui @-märki kontaktandmete tulbas ei ole, siis jääb lahter sellel real tühjaks
  select(nimi, meil) %>% 
  filter(meil != "") 
```

Regulaaravaldist `^.*?([^@ ,]+@[^@ ,]+).*$` võib lugeda nii:   
Kontaktandmete rida algab (`^`),   
rea alguses võib olla ükskõik mis sümboleid (`.`) ükskõik kui mitu korda (`*`),   
kuni (`?`) tuleb see osa, 
mida alles tahame jätta `()`.  
Alles jätame sellise järjendi, kus on \@ sümbol,  
sellest vasakul on vähemalt üks (`+`) sümbol, mis ei ole (`[^]`) üks kantsulgudes täpsustatu (\@, tühik ega koma)  
ning \@-st paremale jääb samuti üks või enam sümbolit, mis ei ole \@, tühik ega koma.  
Kõik, mis sellele järjendile järgneb, võib olla jällegi ükskõik mis sümbol (`.`) ükskõik mitu korda (`*`) kuni rea lõpuni välja (`$`).    

`\\1` käsus `gsub()` ütleb, et jätame alles ainult sulgude vahel oleva järjendi (kuna allesjäetavat on iga rea peale ainult 1, siis sellest ka number).  


Kuna *tidyverse* on laaditud, siis võiks tegelikult kasutada `grepl()` ja `gsub()` funktsioonide asemel vastavalt `stringr` paketi funktsioone `str_detect()` ja `str_replace_all()`.  


## Grupeerimine ja kokkuvõtted

Funktsioon **`summarise()`** laseb teha meie andmetest kõiksugu kokkuvõtteid, mis talletatakse eraldi tabelitesse.

```{r, eval = F}
# osalejate arv kokku
kysimustik %>%
  summarise(n = n()) # funktsioon n() loeb vaatlusi kokku

# osalejate keskmine vanus
kysimustik %>%
  summarise(n = n(),
            keskmine = mean(synniaasta),
            mediaan = median(synniaasta))
```

Oluliselt kasulikumaks muutub `summarise()` funktsioon aga siis, kui seda kasutada koos funktsiooniga **`group_by()`**, mis grupeerib andmeid ühe või enama tunnuse põhjal ning laseb kokkuvõtteid teha iga tunnuse taseme põhjal eraldi.

```{r, eval = F}
# Vaatluste arv, keskmine sünniaasta ja sünniaasta mediaan õppekavade järgi
kysimustik %>%
  group_by(oppekava) %>%
  summarise(n = n(),
            keskmine = mean(synniaasta),
            mediaan = median(synniaasta)) %>%
  ungroup() %>%
  arrange(desc(n)) 
```

Sisuliselt teevad siin `group_by()` ja `summarise()` sama asja, mida funktsioon `tapply()`, mida oleme ka kursusel kasutanud. Vahe on selles, et `tapply()` käsu väljund on vektor, aga `group_by()`+`summarise()` annavad väljundiks andmetabeli (kuhu võib lisada ka muid kokkuvõtteid).

```{r, eval = F}
tapply(kysimustik$synniaasta, kysimustik$oppekava, mean)
```


Nagu öeldud, võib grupeerida andmeid ka mitme tunnuse põhjal. Leiame näiteks, mis on olnud eri aastatel kõige populaarsem (= sagedamini valitud) vastus oma programmeerimisoskuste kohta. Selleks peame kõigepealt kokku lugema iga aasta kohta eraldi iga vastuse valinud osalejad (= grupeerime aasta ja programmeerimisoskuse järgi).   
`summarise()` hülgab alati pärast oma töö lõpetamist ühe grupeerimise aluseks oleva tunnuse, aga kui meil on grupeerimise aluseks mitu tunnust, siis teised jätab alles. Nii et pärast `summarise()` funktsiooni jooksutamist on meie andmed edasi grupeeritud ainult tunnuse `aasta` põhjal. Seega saame filtreerida andmetest välja ainult need read, millel on suurim väärtus igal vaadeldaval aastal.   

```{r, eval = F}
kysimustik %>%
  group_by(aasta, programmeerimisoskus) %>%
  summarise(n = n()) %>%
  filter(n == max(n))
```

Kui me loobuksime pärast `summarise()` funktsiooni kõikidest gruppidest (`.groups = "drop"`), saaksime vastuseks ainult ühe aasta ja vastusevariandi.  

```{r, eval = F}
kysimustik %>% 
  group_by(aasta, programmeerimisoskus) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n == max(n))
```


Harjutuses 1 saadud vastus selle kohta, mis aastal on kursusel olnud kõige rohkem kohvijoojaid, ei rahulda meid päriselt, sest see on esitatud absoluutarvuna ega võta arvesse seda, kui palju mingil aastal üldse osalejaid oli. `group_by()` ja `summarise()` aitavad meil aga arvutada kohvijoojate **osakaalu** iga aasta kohta eraldi.


```{r, eval = F}
# Millisel aastal on olnud kõige suurem kohvijoojate osakaal?
kysimustik %>%
    group_by(aasta, lemmikjook) %>%
    summarise(vastajaid = n()) %>%
    mutate(prop = vastajaid/sum(vastajaid)) %>% # arvuta lemmikjoogi osakaalud gruppides
    ungroup() %>% # eemalda grupid
    filter(lemmikjook == "Kohv") %>%
    filter(prop == max(prop)) %>%
    .$aasta
```


Lisaks funktsioonile `n()`, mis loeb vaatlusi kokku, ning juba tuttavatele funktsioonidele `min()`, `max()`, `mean()`, `median()` jm, on kasulik mh ka näiteks funktsioon **`n_distinct()`**, mis loeb kokku mingi tunnuse kõik unikaalsed väärtused kas siis terves andmestikus või selle alamosades.  


```{r, eval = F}
# Kui palju eri õppekavasid on eri aastatel olnud esindatud?
kysimustik %>%
  group_by(aasta) %>%
  summarise(oppekavasid = n_distinct(oppekava))
```


## Harjutused


**Harjutus 4**

Leia kandidaatide andmestikust, millistes valimisnimekirjades on protsentuaalselt kõige rohkem jäära tähtkujust kandidaate.  

1. Grupeeri kandidaatide andmestik valimisnimekirja (`nimekiri_voi_uksikkandidaat`) ja tähtkuju alusel.  
2. Tee igas grupis kokkuvõte funktsiooniga `summarise()`, milles loed kokku iga grupi vaatluste arvu funktsiooniga `n()`.  
3. Lisa andmestikku uus tulp `prots`, kuhu lisad iga tähemärgi esindajate osakaalu kõikidest tähemärkidest igas grupis (= valimisnimekirjas).   
4. Filtreeri andmetest välja ainult read, kus tulpa `sodiaak` väärtus on `Jäär`.  
5. Järjesta andmed osakaalu tulba järgi kahanevalt või võta välja lihtsalt rida, kus on osakaalu tulbas on kõige suurem väärtus.  


```{r, class.source = 'fold-hide', eval = F}
kandidaadid %>%
  group_by(nimekiri_voi_uksikkandidaat, sodiaak) %>%
  summarise(n = n()) %>%
  mutate(prots = n/sum(n)) %>%
  filter(sodiaak == "Jäär") %>%
  arrange(desc(prots))  
```


**Harjutus 5**

Järjesta harjutuses 2 tehtud graafikul kandidaatide vanuse jaotumise kohta eri valimisnimekirjades erakondade nimed selle järgi, kui suur on nendes kandidaatide mediaanvanus. 

1. Lisa kandidaatide andmestikku uuesti vanuse tulp.  
2. Grupeeri vaatlused valimisnimekirja järgi.  
3. Leia `summarise()` funktsiooni abil iga grupi kandidaatide mediaanvanus.  
4. Järjesta tabel mediaanvanuse tulba järgi.  
5. Võta **vektorina** välja valimisnimekirja tulp ja salvesta see objekti `nimekiri`.  
6. Lisa harjutuses 2 tehtud graafikule kiht `scale_x_discrete(limits = ...)`, kus punktiiri asemele tuleb panna saadud nimekirjade vektor.  

```{r, class.source = 'fold-hide', eval = F}
kandidaadid %>%
  mutate(vanus = lubridate::time_length(as.Date("2019-03-03")-kandidaadid$sunniaeg, "years") %>% round(., 0)) %>%
  group_by(nimekiri_voi_uksikkandidaat) %>%
  summarise(mediaanvanus = median(vanus)) %>%
  arrange(mediaanvanus) %>%
  .$nimekiri_voi_uksikkandidaat -> nimekiri

kandidaadid %>%
  mutate(vanus = lubridate::time_length(as.Date("2019-03-03")-kandidaadid$sunniaeg, "years") %>% round(., 0)) %>%
  ggplot() +
  geom_boxplot(aes(x = nimekiri_voi_uksikkandidaat, y = vanus)) +
  geom_hline(aes(yintercept = mean(vanus)), color = "red", linetype = "dashed", size = 1) +
  scale_x_discrete(limits = nimekiri) +
  coord_flip() +
  labs(x = "")
```

Tegelikult on küll ka lihtsam viis:

```{r}
kandidaadid %>%
  mutate(vanus = lubridate::time_length(as.Date("2019-03-03")-kandidaadid$sunniaeg, "years") %>% round(., 0)) %>%
  ggplot() +
  geom_boxplot(aes(x = reorder(nimekiri_voi_uksikkandidaat, vanus, FUN = median), 
                   y = vanus)) +
  geom_hline(aes(yintercept = mean(vanus)), color = "red", linetype = "dashed", size = 1) +
  coord_flip() +
  labs(x = "")
```




## Pikk ja lühike tabel

Küsimustiku andmestikus on iga osaleja eraldi real ning igat osalejat iseloomustab tulpades iga tunnuse puhul üks kindel väärtus.

Oletame aga, et oleme oma küsimustiku koostanud nii, et oleme muud andmed osaleja kohta kogunud nii nagu praeguseski küsimustikus, aga õppekavad pannud eraldi tulpadesse ja iga tulba väärtusteks "ei" ja "jah", vastavalt sellele, kas osaleja õpib vastaval õppekaval või mitte. Näiteks kui osaleja õpiks eesti ja soome-ugri keeleteadust, oleks tal tulbas "eesti ja soome-ugri keeleteadus" väärtus "jah" ja tulpades "ajalugu", "filosoofia" jne väärtus "ei". Antud juhul oleks selline tabelistruktuur väga kohmakas ja liiane, sest teame, et meie küsitluses ei märkinud osalejatest keegi ennast niikuinii mitmele õppekavale korraga.  

```{r}
load("data/kysimustik_2022_lai.RData")
```


<center>
![](imgs/tidy.jpg)
<p><a href = "https://r4ds.had.co.nz/tidy-data.html">https://r4ds.had.co.nz/tidy-data.html</a></p>
</center>

Selleks, et sellisest nn **laiast tabelist** teha **pikk tabel**, kus mitme tulba kategooriad (meie näites õppekavade nimed) oleksid ühes tulbas, saame kasutada funktsiooni **`pivot_longer()`**. Laia tabelit kasutatakse sageli just sellise nn *dummy coding*'u jaoks, et kasutada andmeid statistilistes mudelites. Sellise kodeerimisskeemi puhul vastandatakse tunnuse üht väärtust kõikide teiste tunnuse väärtustega, uurides nt selle konkreetse taseme mõju uuritava tunnuse varieerumise seletamisel.     

```{r, eval = F}
kysimustik_lai %>%
  pivot_longer(data = ., # punkt viitab tagasi laiale küsimustikule
               cols = 10:25, # millised tulbad ühte tulpa kokku võtta?
               names_to = "oppekava", # mis nimega tulpa need tulbad kokku võtta?
               values_to = "oppekava_vaartused")# mis tulpa lähevad lahtrite väärtused?
```

Näeme, et meil tekib tabel, milles on tervelt 1040 rida, ehkki osalejaid kursusel on olnud kõigest 65. Seda sellepärast, et iga osaleja kohta tekib lisaks tema tõelisele õppekavale (`oppekava_vaartused == "jah"`) ka mitu rida nende õppekavadega, kus osaleja tegelikult ei õpi (`oppekava_vaartused == "ei"`).  

Peaksime niisiis pärast tabeli pikaks tegemist filtreerima sealt välja ainult need read, kus tulbas `oppekava_vaartused` on "jah" ning selle tulba enda välja viskama, sest tulpa, kus igal real on lihtsalt "jah", ei ole meil vaja.

```{r, results = 'hide'}
(kysimustik_lai %>%
   pivot_longer(data = ., 
                cols = 10:25, 
                names_to = "oppekava", 
                values_to = "oppekava_vaartused") %>%
   filter(oppekava_vaartused == "jah") %>%
   select(-oppekava_vaartused) -> kysimustik_lai_pikendatud)
```

Nüüd on meie tabel samasugune, nagu seda kogu aeg oleme kasutanud. Pikka tabelit on oluliselt mugavam kasutada ka **ggplotis**, kus ühele kujunduselemendile peaks vastama üks kindel andmetabeli tulp (mitte mitu tulpa korraga).  


Teinekord aga võib meil vaja minna just laia tabelit. Selleks saab kasutada funktsiooni **`pivot_wider()`**. Muudame oma pika küsimustiku tabeli uuesti laiaks nii, et iga õppekava tunnuse väärtus on omaette tulbas ja tulbas on väärtused "Jah" ja "Ei".  

```{r, eval = F}
kysimustik %>%
  mutate(vastus = "Jah") %>% # teeme uue tulba, kus on ainult väärtus "Jah"
  pivot_wider(data = ., 
              names_from = oppekava, # millised tulba väärtused eraldi tulpadeks jaotada?
              values_from = vastus, # mis tulba väärtused lähevad lahtritesse? 
              values_fill = "Ei") # mis väärtus märkida NA-de asemele?
```

Laia tabelit ja `pivot_wider()` funktsiooni peame kasutama ka siis, kui tahame saada näiteks risttabelit kahe või enama tunnuse ühisjaotusest, aga tahame säilitada samas andmetabeli ehk *data frame*'i struktuuri. 

```{r, eval = F}
kysimustik %>%
  group_by(lemmikloom, lemmikjook) %>%
  summarise(n = n()) %>%
  pivot_wider(., 
              names_from = lemmikjook, 
              values_from = n, 
              values_fill = 0)

# Võrdle
kysimustik %>%
  select(lemmikloom, lemmikjook) %>%
  table()
```


## Harjutus

**Harjutus 6**

Lisa joonisele, mille enne tegid ja mille koodi all näed, kiht, kus kohvi- ja teejoojate mediaanidele karpdiagrammil oleks lisaks eraldi värviliste sümbolitega näidatud ka iga aasta vastajate **üldine** mediaanvanus ja keskmine vanus.  

```{r, eval = F}
kysimustik %>%
  mutate(vanus = as.numeric(as.character(aasta))-synniaasta) %>%
  ggplot() +
  geom_boxplot(aes(x = aasta, y = vanus, fill = lemmikjook))
```

1. Tee küsimustiku andmestikku uus tulp, kuhu arvutad vastajate vanuse.  
2. Grupeeri vaatlused aasta põhjal.  
3. Kasuta funktsiooni `summarise()`, et leida iga aasta keskmine vanus ja mediaanvanus.  
4. Kasuta funktsiooni `pivot_longer()`, kus keskväärtused ise on ühes tulbas ning neid täpsustav liik ("keskmine", "mediaan") teises tulbas. Salvesta see eraldi objekti `yldised`.
5. Lisa ülaltoodud joonise koodi uus punktikiht `geom_point()`, kus andmed võtad sellest uuest objektist (`data = yldised`), x-teljele määrad aasta, y teljele keskväärtused ja värviga näitad seda, kas tegemist on mediaani või keskmisega.  

```{r, class.source = 'fold-hide', eval = F}
kysimustik %>%
  mutate(vanus = as.numeric(as.character(aasta))-synniaasta) %>%
  group_by(aasta) %>%
  summarise(keskmine = mean(vanus),
            mediaan = median(vanus)) %>%
  pivot_longer(., 
               cols = c("keskmine", "mediaan"), 
               names_to = "liik", 
               values_to = "väärtus") -> yldised

kysimustik %>%
  mutate(vanus = as.numeric(as.character(aasta))-synniaasta) %>%
  ggplot() +
  geom_boxplot(aes(x = aasta, y = vanus, fill = lemmikjook)) +
  geom_point(data = yldised, 
             aes(x = aasta, y = väärtus, color = liik),
             size = 5, stroke = 2, shape = 4) +
  scale_color_manual(values = c("cornsilk4", "darkgoldenrod2"))
```


## Näide ja harjutused

Andmestikus `kiltsi_hk.xlsx` on ajaloolase Kersti Lusti koostatud andmestik Kiltsi vallakohtuprotokollide hagejate ja kostjate kohta aastatest 1872-1890. Kuna andmestik ega selle põhjal tehtud analüüsid ei ole veel avaldatud, on meie harjutamisandmestik saadud originaalandmete segiajamise teel. See tähendab, et protokollide numbrid, aastaarvud, teemad ja osalejate iseloomustamiseks kasutatud tunnused on juhuslikult omavahel kokku saanud ega vasta tegelikele andmetele.

Tabelis on märgitud järgmised tunnused:  

- protokolli unikaalne ID (`protokolli_id`),  
- aasta (`aasta`),  
- kuu (`kuu`),  
- päev (`päev`),  
- teema (`teema`), 
- hagejate (H) ja kostjate (K)  
  - unikaalne ID (nt `H1_ID`),  
  - sugu (`H1_sugu`),  
  - amet (`H1_amet`),  
  - elukoht (`H1_vald`).
  
Praegu on andmestik laias formaadis, st iga protokolli kohta on üks rida ning selle osaliste info (ükskõik kui palju neid osalisi on) on laiali eraldi tulpades. Korrastame selle laias formaadis tabel pikka formaati nii, et iga protokolli osaleja oleks eraldi real. Nii et kui protokollis on näiteks ainult üks hageja ja üks kostja, oleks selle protokolli kohta 2 rida; kui protokollis on üks hageja ja kaks kostjat, siis 3 rida jne.     

Kasutame nii funktsiooni `pivot_longer()` kui ka `pivot_wider()`.   

Selleks, et Exceli faile otse R-i lugeda, saab kasutada näiteks paketti `xlsx`, `readxl` või `openxlsx`.  

```{r}
# install.packages("xlsx")
# install.packages("readxl")
# install.packages("openxlsx")
kiltsi <- xlsx::read.xlsx2("data/kiltsi_hk.xlsx", 
                           sheetIndex = 1)

# kiltsi <- readxl::read_excel("../data/kiltsi_hk.xlsx") # loeb tühjad lahtrid sisse NA-dena
# kiltsi <- openxlsx::read.xlsx("../data/kiltsi_hk.xlsx") # loeb tühjad lahtrid sisse NA-dena
```

Teeme esmalt laiast tabelist pika nii, et kõik Kiltsi tabeli tulpade pealkirjad, milles H-le või K-le järgneb 1-2 numbrit ning alakriips (nt `H1_amet`, `K10_sugu`), lõigatakse alakriipsu koha pealt pooleks ning enne alakriipsu olev osa (nt `H1`, `K10`) pannakse uude tulpa `nimi` ja pärast alakriipsu olev osa (`amet`, `sugu`) tulpa `klass`. Tabeli lahtrite väärtused pannakse tulpa `väärtused`.    

```{r}
kiltsi %>%
  pivot_longer(., # tee andmestikust pikk tabel
               cols = grep("^[HK][0-9]{1,2}_.*$", # otsi H/K, 1-2 numbri ja alakriipsu järjendit
                           names(kiltsi), # Kiltsi tabeli tulbanimedest
                           value = TRUE), # anna otsingu vasteks nende tulbanimedega vektor
               names_sep = "_", # lõika tulbanimed alakriipsu koha pealt pooleks
               names_to = c("nimi", "klass"), # esimene pool pane tulpa "nimi" ja teine tulpa "klass"
               values_to = "väärtused") # algsed laia tabeli lahtrite väärtused pane tulpa "väärtused"
```


Järgmiseks jätame andmestikust välja need read, kus tulbas `väärtused` ei ole midagi kirjas.  


```{r}
kiltsi %>%
  pivot_longer(.,
               cols = grep("^[HK][0-9]{1,2}_.*$", 
                           names(kiltsi), 
                           value = TRUE),
               names_sep = "_",
               names_to = c("nimi", "klass"),
               values_to = "väärtused") %>%
  filter(väärtused != "") # jäta välja read, kus tulbas "väärtused" ei ole midagi
```


Nüüd teeme meie eriti pikast tabelist uuesti laiema tabeli, kus kõik erinevad väärtused tulbas `klass` saaksid omaette tulpadeks (nt `ID`, `sugu`, `amet`), mille lahtritesse pannakse väärtused tulbast `väärtused`.  

```{r}
kiltsi %>%
  pivot_longer(.,
               cols = grep("^[HK][0-9]{1,2}_.*$", 
                           names(kiltsi), 
                           value = TRUE),
               names_sep = "_",
               names_to = c("nimi", "klass"),
               values_to = "väärtused") %>%
  filter(väärtused != "") %>%
  pivot_wider(., # tee andmestikust uuesti lai(em) tabel
              names_from = "klass", # kus lisatavate tulpade nimed võetakse tulbast "klass"
              values_from = "väärtused") # ja nende tulpade väärtused tulbast "väärtused"
```

Lõpuks lisame tabelisse tulba `roll`, mille väärtuseks saab `hageja`, kui samal real on tulbas `nimi` täht H, ja `kostja`, kui samal real on tulbas `nimi` täht K. Nime tulba kustutame ära. Suuname lõppväljundi uude objekti nimega `kiltsi_puhas`.     

```{r}
kiltsi %>%
  pivot_longer(.,
               cols = grep("^[HK][0-9]{1,2}_.*$", 
                           names(kiltsi), 
                           value = TRUE),
               names_sep = "_",
               names_to = c("nimi", "klass"),
               values_to = "väärtused") %>%
  filter(väärtused != "") %>%
  pivot_wider(.,
              names_from = "klass",
              values_from = "väärtused") %>%
  mutate(roll = case_when(grepl("^H", nimi) ~ 
                            "hageja", 
                          grepl("^K", nimi) ~ 
                            "kostja")) %>%
  select(-nimi) -> kiltsi_puhas
```


Proovi lahendada järgmised ülesanded! Arvesta muidugi, et vastused ei ole tegelikult õiged, sest tegeleme juhuslikult sassi aetud andmetega.  

**Harjutus 7**

Uuri tulpdiagrammil, kas Kiltsi protokollides esinevate hagejate ja kostjate sooline jaotumine on erinev. Jäta välja kummagi tunnuse puhul puuduvad väärtused.  

```{r, class.source = 'fold-hide'}
ggplot(kiltsi_puhas %>% 
         filter(!is.na(sugu))) +
  geom_bar(aes(x = roll, fill = sugu), position = "fill")

```

**Harjutus 8**

Kas naisi on meestega võrreldes hakanud aastate jooksul rohkem kohtus käima? Kas see erineb rolliti (hageja vs. kostja rollis)? Püüa vastata tulpdiagrammiga.   

Võid aastat käsitleda ka kategoriaalse tunnusena.   

```{r, class.source = 'fold-hide'}
kiltsi_puhas %>%
  filter(!is.na(sugu)) %>%
  ggplot() +
  geom_bar(aes(fill = sugu, x = aasta), position = "fill")

kiltsi_puhas %>%
  filter(!is.na(sugu)) %>%
  ggplot() +
  geom_bar(aes(fill = sugu, x = aasta), position = "fill") +
  coord_flip() +
  facet_wrap("roll")
```

```{r, class.source = 'fold-hide'}
kiltsi_puhas %>%
  group_by(aasta, sugu) %>%
  summarise(n = n()) %>%
  mutate(prop = n/sum(n)) %>%
  filter(sugu == "naine") %>%
  ggplot() +
  geom_point(aes(x = aasta, y = prop))

kiltsi_puhas %>%
  group_by(aasta, sugu, roll) %>%
  summarise(n = n()) %>%
  ungroup() %>%
  group_by(aasta, roll) %>%
  mutate(prop = n/sum(n)) %>%
  filter(sugu == "naine") %>%
  ggplot() +
  geom_point(aes(x = aasta, y = prop)) +
  coord_flip() +
  facet_wrap("roll")
```


## Kasutatud funktsioonide sõnastik

`filter()` - vali andmestikust ridu   
`select()` - vali andmestikust tulpasid  
`pull()` - vali andmestikust tulp vektorina  
`arrange()` - järjesta andmestik mingi tunnuse alusel  
`mutate()` - lisa andmestikku uus tulp  
`group_by()` - grupeeri andmestiku vaatlused mingi(te) tunnus(t)e alusel   
`summarise()` - tee andmestikust kokkuvõtteid  
`n()` - loe vaatlusi kokku  
`n_distinct()` - leia *erinevate* väärtuste arv    
`pivot_longer()` - tee laiast tabelist pikk  
`pivot_wider()` - tee pikast tabelist lai  

